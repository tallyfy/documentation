---
description: The OAuth 2.0 Client Credentials flow enables machine-to-machine authentication
  for third-party applications requiring manual setup by Tallyfy Support with client
  credentials that generate application-level tokens valid for 7 days and optional
  user-specific tokens valid for 3 months for acting as individual users.
id: 5a7731c3f4ae6de6ca627890e5b0c9f0
lastUpdated: 2026-01-20
sidebar:
  order: 2
title: Use the Client Credentials Flow
---

import { Tabs, TabItem } from '@astrojs/starlight/components';

## Overview

The OAuth 2.0 Client Credentials flow is designed for machine-to-machine authentication, typically used by third-party applications or backend services that need to interact with the Tallyfy API independently or on behalf of users within an organization.

This method requires you to first obtain a `Client ID` and `Client Secret` from Tallyfy Support.

:::caution[Enterprise Feature & Setup Required]
The client credentials grant type is only available to paid Tallyfy organizations and requires manual setup by Tallyfy Support. It is not accessible during free trials or by default. Contact Tallyfy Support to request access and explain your integration use case.
:::

## Authentication flow

This diagram shows the complete OAuth 2.0 Client Credentials flow from initial setup through API usage.

```d2
direction: down

App: "Your Application" {
  shape: rectangle
  style.fill: "#f5f5f5"
}

Support: "Tallyfy Support" {
  shape: person
  style.fill: "#e6ffe6"
}

Auth: "Tallyfy Auth\n(account.tallyfy.com)" {
  shape: rectangle
  style.fill: "#e6f3ff"
}

API: "Tallyfy API\n(go.tallyfy.com/api)" {
  shape: cylinder
  style.fill: "#ffe6e6"
}

# One-time Setup
App -> Support: "1. Request client\ncredentials" {
  style.stroke: "#333"
}

Support -> App: "2. Provide Client ID\n& Client Secret" {
  style.stroke: "#333"
  style.stroke-dash: 3
}

# Application-Level Authentication
App -> Auth: "3. POST /oauth/token\n(client_credentials)" {
  style.stroke: "#333"
  style.stroke-width: 2
}

Auth -> App: "4. Access token\n(expires in 7 days)" {
  style.stroke: "#333"
  style.stroke-dash: 3
}

App -> API: "5. API Request with\nBearer token + headers" {
  style.stroke: "#333"
}

API -> App: "6. Response data" {
  style.stroke: "#333"
  style.stroke-dash: 3
}

# Optional: User-Specific Operations
App -> API: "7. POST /applications/users\n(provision user)" {
  style.stroke: "#666"
}

API -> App: "8. User-specific token" {
  style.stroke: "#666"
  style.stroke-dash: 3
}

App -> API: "9. GET /organizations/tasks\n(as user)" {
  style.stroke: "#666"
}

API -> App: "10. User's tasks data" {
  style.stroke: "#666"
  style.stroke-dash: 3
}

# Token Refresh Required Before Expiry
App -> Auth: "11. POST /oauth/token\n(refresh before expiry)" {
  style.stroke: "#333"
  style.stroke-dash: 5
}

Auth -> App: "12. New access token" {
  style.stroke: "#333"
  style.stroke-dash: 5
}
```

### What to notice

- **Step 1 is manual**: Contacting Tallyfy Support for credentials is a one-time setup process that cannot be automated
- **Two token types**: Application tokens (for system operations) vs user-specific tokens (for acting as a user)
- **Different expiration times**: Application tokens expire in 7 days (604,800 seconds), user-specific tokens expire in 3 months (7,776,000 seconds)

### Use cases

This integration pattern is ideal for organizations using Tallyfy that want to:

-   Embed Tallyfy functionality within their own software.
-   Provide integrated workflow capabilities to their users without requiring separate Tallyfy logins visible in your app.
-   Automate process management or user provisioning programmatically.
-   System-level integrations (e.g., reporting, data synchronization).
-   Handle Tallyfy user provisioning programmatically

### Steps

#### 1. Request client credentials

-   Contact Tallyfy Support to request client credentials (`Client ID` and `Client Secret`).
-   Explain your integration needs and use case.
-   Tallyfy will provide the credentials for your organization. Store these credentials securely.

#### 2. Obtain an application access token

Your application first needs its *own* access token to perform actions like Tallyfy user provisioning or getting user-specific tokens.

-   **Endpoint:** `POST /oauth/token`
-   **OAuth Endpoint:** `https://account.tallyfy.com/oauth/token`
-   **Content-Type:** `application/x-www-form-urlencoded`
-   **Request Body (form-encoded):**
    -   `grant_type`: `client_credentials`
    -   `client_id`: Your Application\'s Client ID
    -   `client_secret`: Your Application\'s Client Secret
    -   `scope`: `*` (or specific scopes if provided by Tallyfy)

<Tabs>
<TabItem label="Javascript">
```javascript
const fetch = require('node-fetch'); // If in Node.js environment
const FormData = require('form-data'); // If in Node.js environment

const clientId = 'YOUR_CLIENT_ID';
const clientSecret = 'YOUR_CLIENT_SECRET';
const tokenUrl = 'https://account.tallyfy.com/oauth/token';

const formData = new FormData();
formData.append('grant_type', 'client_credentials');
formData.append('client_id', clientId);
formData.append('client_secret', clientSecret);
formData.append('scope', '*'); // Optional, use specific scopes if needed

fetch(tokenUrl, {
    method: 'POST',
    body: formData,
    // Headers for FormData are usually set automatically by fetch/browser
    // but ensure Content-Type is 'application/x-www-form-urlencoded' if manually setting
})
.then(response => {
    if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
    }
    return response.json();
})
.then(data => {
    console.log('Success:', data);
    // Use data.access_token for subsequent API calls
})
.catch(error => {
    console.error('Error fetching token:', error);
});
```
</TabItem>
<TabItem label="Python">
```python
import requests

client_id = 'YOUR_CLIENT_ID'
client_secret = 'YOUR_CLIENT_SECRET'
token_url = 'https://account.tallyfy.com/oauth/token'

payload = {
    'grant_type': 'client_credentials',
    'client_id': client_id,
    'client_secret': client_secret,
    'scope': '*' # Optional
}

# Use 'data' for application/x-www-form-urlencoded
response = requests.post(token_url, data=payload)

if response.status_code == 200:
    token_data = response.json()
    print("Success:", token_data)
    # Use token_data['access_token']
else:
    print(f"Error: {response.status_code}")
    print(response.text)

```
</TabItem>
<TabItem label="Java">
```java
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.HashMap;
import java.util.Map;
import java.util.stream.Collectors;

public class TallyfyClientCredentials {

    public static void main(String[] args) throws Exception {
        String clientId = "YOUR_CLIENT_ID";
        String clientSecret = "YOUR_CLIENT_SECRET";
        String tokenUrl = "https://account.tallyfy.com/oauth/token";

        Map<String, String> formData = new HashMap<>();
        formData.put("grant_type", "client_credentials");
        formData.put("client_id", clientId);
        formData.put("client_secret", clientSecret);
        formData.put("scope", "*"); // Optional

        String form = formData.entrySet()
                .stream()
                .map(e -> e.getKey() + "=" + URLEncoder.encode(e.getValue(), StandardCharsets.UTF_8))
                .collect(Collectors.joining("&"));

        HttpClient client = HttpClient.newHttpClient();
        HttpRequest request = HttpRequest.newBuilder()
                .uri(URI.create(tokenUrl))
                .header("Content-Type", "application/x-www-form-urlencoded")
                .POST(HttpRequest.BodyPublishers.ofString(form))
                .build();

        HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());

        if (response.statusCode() == 200) {
            System.out.println("Success:");
            System.out.println(response.body());
            // Parse JSON response to get access_token
        } else {
            System.err.println("Error fetching token: " + response.statusCode());
            System.err.println(response.body());
        }
    }
}
```
</TabItem>
<TabItem label="Go">
```go
package main

import (
	"fmt"
	"net/http"
	"net/url"
	"strings"
    "io/ioutil"
)

func main() {
	clientId := "YOUR_CLIENT_ID"
	clientSecret := "YOUR_CLIENT_SECRET"
	tokenUrl := "https://account.tallyfy.com/oauth/token"

	data := url.Values{}
	data.Set("grant_type", "client_credentials")
	data.Set("client_id", clientId)
	data.Set("client_secret", clientSecret)
	data.Set("scope", "*") // Optional

	client := &http.Client{}
	req, err := http.NewRequest("POST", tokenUrl, strings.NewReader(data.Encode()))
	if err != nil {
		fmt.Println("Error creating request:", err)
		return
	}
	req.Header.Add("Content-Type", "application/x-www-form-urlencoded")

	resp, err := client.Do(req)
	if err != nil {
		fmt.Println("Error sending request:", err)
		return
	}
	defer resp.Body.Close()

    bodyBytes, err := ioutil.ReadAll(resp.Body)
    if err != nil {
        fmt.Println("Error reading response body:", err)
        return
    }
    bodyString := string(bodyBytes)


	if resp.StatusCode == http.StatusOK {
		fmt.Println("Success:")
		fmt.Println(bodyString)
        // Parse JSON response to get access_token
	} else {
		fmt.Printf("Error: %d\n", resp.StatusCode)
		fmt.Println(bodyString)
	}
}

```
</TabItem>
<TabItem label="C++">
```cpp
#include <iostream>
#include <string>
#include <vector>
#include <cpprest/http_client.h>
#include <cpprest/filestream.h>

using namespace web;
using namespace web::http;
using namespace web::http::client;

pplx::task<void> GetClientCredentialsToken()
{
    http_client client(U("https://account.tallyfy.com/oauth/token"));

    uri_builder builder;
    builder.append_query(U("grant_type"), U("client_credentials"));
    builder.append_query(U("client_id"), U("YOUR_CLIENT_ID"));
    builder.append_query(U("client_secret"), U("YOUR_CLIENT_SECRET"));
    builder.append_query(U("scope"), U("*")); // Optional

    http_request request(methods::POST);
    request.headers().set_content_type(U("application/x-www-form-urlencoded"));
    request.set_body(builder.query());


    return client.request(request).then([](http_response response)
    {
        if (response.status_code() == status_codes::OK)
        {
            return response.extract_json();
        }
        else
        {
            // Handle error - extracting body might be useful
             return response.extract_string().then([](utility::string_t body) {
                 std::wcerr << L"Error response body: " << body << std::endl;
                 // Throw or return an error indicator wrapped in json::value for consistency if needed
                 return pplx::task_from_result(json::value::null());
             });
        }
    }).then([](pplx::task<json::value> previousTask)
    {
        try
        {
            json::value const & v = previousTask.get();
            if (!v.is_null())
            {
                 std::wcout << L"Success:\n" << v.serialize() << std::endl;
                // Use v.at(U("access_token")).as_string()
            } else {
                std::wcerr << L"Error fetching token (check previous logs)." << std::endl;
            }
        }
        catch (const http_exception& e)
        {
            std::wcerr << L"HTTP Exception caught: " << e.what() << std::endl;
        }
        catch (const std::exception& e)
        {
             std::wcerr << L"Exception caught: " << e.what() << std::endl;
        }
         catch (...) {
             std::wcerr << L"Unknown exception caught" << std::endl;
         }
    });
}

int main()
{
    try
    {
        GetClientCredentialsToken().wait();
    }
    catch (const std::exception &e)
    {
        std::wcerr << L"Error in main: " << e.what() << std::endl;
    }
     catch (...) {
         std::wcerr << L"Unknown exception caught in main" << std::endl;
     }

    return 0;
}
// Note: Requires C++ REST SDK (Casablanca). Ensure proper setup and linking.
// This is a basic example; robust applications need better error handling,
// JSON parsing, and potentially asynchronous management.
```
</TabItem>
<TabItem label="C#">
```csharp
using System;
using System.Collections.Generic;
using System.Net.Http;
using System.Threading.Tasks;

public class TallyfyAuth
{
    private static readonly HttpClient client = new HttpClient();

    public static async Task GetClientCredentialsToken()
    {
        var clientId = "YOUR_CLIENT_ID";
        var clientSecret = "YOUR_CLIENT_SECRET";
        var tokenUrl = "https://account.tallyfy.com/oauth/token";

        var formContent = new FormUrlEncodedContent(new[]
        {
            new KeyValuePair<string, string>("grant_type", "client_credentials"),
            new KeyValuePair<string, string>("client_id", clientId),
            new KeyValuePair<string, string>("client_secret", clientSecret),
            new KeyValuePair<string, string>("scope", "*") // Optional
        });

        try
        {
            HttpResponseMessage response = await client.PostAsync(tokenUrl, formContent);
            string responseBody = await response.Content.ReadAsStringAsync();

            if (response.IsSuccessStatusCode)
            {
                Console.WriteLine("Success:");
                Console.WriteLine(responseBody);
                // TODO: Deserialize JSON (e.g., using System.Text.Json or Newtonsoft.Json)
                // var tokenData = JsonSerializer.Deserialize<TokenResponse>(responseBody);
                // Console.WriteLine($"Access Token: {tokenData.AccessToken}");
            }
            else
            {
                Console.WriteLine($"Error: {response.StatusCode}");
                Console.WriteLine(responseBody);
            }
        }
        catch (HttpRequestException e)
        {
            Console.WriteLine($"Request Exception: {e.Message}");
        }
    }

    // Example usage (e.g., in a Main method)
    // static async Task Main(string[] args)
    // {
    //     await GetClientCredentialsToken();
    // }

    // Define a class to deserialize the JSON response if needed
    // public class TokenResponse
    // {
    //     [JsonPropertyName("access_token")]
    //     public string AccessToken { get; set; }
    //     [JsonPropertyName("token_type")]
    //     public string TokenType { get; set; }
    //     [JsonPropertyName("expires_in")]
    //     public int ExpiresIn { get; set; }
    // }
}
```
</TabItem>
</Tabs>

**Response:**

```json
{
    "token_type": "Bearer",
    "expires_in": 604800,
    "access_token": "APP_LEVEL_ACCESS_TOKEN_EXAMPLE..."
}
```

:::note[Token Expiration]
Application access tokens are valid for 7 days (604,800 seconds). Your application should request a new token before expiration - simply repeat the POST request with your credentials.
:::

:::note[Endpoint URLs]

-   **OAuth Token Endpoint:** `https://account.tallyfy.com/oauth/token` - for obtaining application tokens
-   **API Base URL:** `https://go.tallyfy.com/api` - for all other API calls after authentication

:::

### 3. Provision users programmatically (Optional)

Using the application-level token, you can create users in your organization:

-   **Endpoint:** `POST https://go.tallyfy.com/api/applications/{orgID}/users`
-   **Headers:**
    -   `Authorization: Bearer {your_app_access_token}` (From Step 2)
    -   `Content-Type: application/json`
    -   `X-Tallyfy-Client: APIClient`
-   **Request Body:**
    -   `first_name` (required): User's first name
    -   `last_name` (required): User's last name
    -   `email` (required): User's email address
    -   `role` (optional): `admin`, `standard`, or `light`
    -   `timezone` (optional): User's timezone

### 4. Generate user-specific access tokens (Optional)

To act *as* a specific user, request a user-specific token using the application token.

-   **Endpoint:** `POST https://go.tallyfy.com/api/applications/{orgID}/users/{email}/token`
-   **Headers:**
    -   `Authorization: Bearer {your_app_access_token}` (From Step 2)
    -   `X-Tallyfy-Client: APIClient`
-   **Note:** No request body required - the user email is in the URL path.

**Response:**

```json
{
    "token_type": "Bearer",
    "expires_in": 7776000,
    "access_token": "USER_SPECIFIC_ACCESS_TOKEN_EXAMPLE..."
}
```

:::note[User Token Validity]
User-specific tokens are valid for 3 months (7,776,000 seconds).
:::

### 5. Make API requests as an application or user

Use the appropriate token (`APP_LEVEL_ACCESS_TOKEN` or `USER_SPECIFIC_ACCESS_TOKEN`) in the `Authorization: Bearer {token}` header for subsequent API calls, along with the standard `Accept` and `X-Tallyfy-Client` headers.

**Example: Get tasks for a specific user (using user-specific token)**

-   **Endpoint:** `GET /organizations/{orgID}/me/tasks`
-   **Base URL:** `https://go.tallyfy.com/api`
-   **Resource Path:** e.g., `/organizations/{org_id}/users`
-   **Full URL:** `https://go.tallyfy.com/api/organizations/{org_id}/users`
-   **Headers:**
    -   `Authorization: Bearer {user_specific_access_token}`
    -   `Accept: application/json`
    -   `X-Tallyfy-Client: APIClient`

*Code examples for making the requests themselves are similar to those shown in the [Personal Access Token](/products/pro/integrations/open-api/code-samples/authentication/personal-access-token/) guide, just substitute the correct token.*

### Security considerations

-   Store client credentials securely (e.g., encrypted secrets management).
-   Protect both application-level and user-specific tokens.
-   Rotate secrets periodically.
-   Use HTTPS for all communications.
-   Implement robust token expiration and refresh logic.

---

import { CardGrid, LinkTitleCard } from "~/components";

## Related articles
<CardGrid>
<LinkTitleCard header="<b>Open Api > API usage as a third-party application instead of a user</b>" href="/products/pro/integrations/open-api/access-api-as-a-third-party-application-instead-of-a-user/" > Third-party applications can integrate with Tallyfy's API using the OAuth 2.0 client credentials flow which involves obtaining client credentials from Tallyfy Support then authenticating to get an application-level token that enables programmatic user provisioning and the generation of user-specific tokens for performing API actions on behalf of individual users within the organization. </LinkTitleCard>
<LinkTitleCard header="<b>Open Api > OAuth authorization flow for third-party applications</b>" href="/products/pro/integrations/open-api/oauth-authorization-flow/" > This guide demonstrates implementing OAuth 2.0 authorization flow for third-party applications to authenticate with Tallyfy without exposing user credentials through a secure redirect-based process that returns access tokens for API authentication. </LinkTitleCard>
<LinkTitleCard header="<b>Open Api > API integration guide</b>" href="/products/pro/integrations/open-api/how-to-integrate-with-tallyfy-using-api/" > The Tallyfy REST API enables workflow automation through two authentication methods (user-based tokens obtained from Settings or application-based OAuth credentials) requiring specific headers and proper token management while supporting multi-organization contexts and webhook integrations with standardized date formats. </LinkTitleCard>
<LinkTitleCard header="<b>Integrations > Open API</b>" href="/products/pro/integrations/open-api/" > The Tallyfy REST API enables developers to build custom integrations with full platform functionality through three authentication methods (user tokens application tokens and OAuth) while providing complete access to process management task operations user administration and data export capabilities with standard JSON responses and reasonable rate limits. </LinkTitleCard>
</CardGrid>