---
description: Power Automate's advanced conditional logic transforms basic if-then
  statements into sophisticated decision-making systems using expressions grouped
  conditions and Switch controls to handle complex Tallyfy data scenarios with multiple
  conditions calculations and edge cases that real business workflows demand.
id: 6549ab6cc62a4067a4590d9af3164cff
sidebar:
  order: 9
title: Advanced conditions and expressions in Power Automate
---

Basic conditional logic (if-this-then-that) works great for simple Tallyfy [processes](/products/pro/tracking-and-tasks/processes/) in Power Automate. But real workflows are messy. They need smarter decision-making - the kind that handles multiple conditions, complex calculations, and edge cases. Let's dive into advanced techniques you can use with your Tallyfy data: expressions, grouped conditions, and the Switch control that'll make your integrations actually handle what your business throws at them.

## Revisiting conditional logic

As covered in our article on [using conditional logic in Power Automate](/products/pro/integrations/middleware/power-automate/using-conditional-logic-in-power-automate/), the **Condition** control is your go-to tool for decision-making in flows that interact with Tallyfy. It checks if something is true or false and sends the flow down different paths. Simple enough. But here's where it gets interesting - we can supercharge these conditions to handle complex Tallyfy data scenarios.

## Working with expressions in conditions

Power Automate expressions are formulas that let you manipulate data from Tallyfy, perform calculations, and access specific properties of your dynamic content. Think of them as your Swiss Army knife for data manipulation. When you combine expressions with conditions, you can build logic that handles the quirks and edge cases in your actual business processes.

To use an expression:
1.  Click inside the value box when configuring a condition (or any field that accepts expressions).
2.  The dynamic content pane will appear. Switch to the **Expression** tab.
3.  Type or select functions to build your expression.



Here are the expression functions you'll use most with Tallyfy data:

*   **String functions:**
    *   `concat('string1', 'string2')`: Joins strings.
    *   `substring('text', startIndex, length)`: Extracts part of a string.
    *   `toLower('TEXT')` / `toUpper('text')`: Converts case (useful for case-insensitive comparisons of Tallyfy [form field](/products/pro/tracking-and-tasks/tasks/what-are-form-fields-in-tallyfy/) values).
    *   `equals('string1', 'string2')`: Compares two strings (often used within an `if` expression for complex logic).
    *   `contains('text', 'searchText')`: Checks if text contains specific searchText.
    *   `startsWith('text', 'searchText')` / `endsWith('text', 'searchText')`.
*   **Date/Time functions:**
    *   `utcNow()`: Gets the current date and time in UTC.
    *   `addDays(timestamp, days, 'format')`: Adds days to a date (e.g., calculating a new due date based on a Tallyfy [task's](/products/pro/tracking-and-tasks/tasks/) start date).
    *   `formatDateTime(timestamp, 'formatString')`: Formats a date/time string (e.g., `'yyyy-MM-dd'`).
*   **Conversion functions:**
    *   `int('stringValue')`: Converts a string (perhaps from a Tallyfy text [form field](/products/pro/tracking-and-tasks/tasks/what-are-form-fields-in-tallyfy/)) to an integer.
    *   `string(value)`: Converts a value to a string.
    *   `float('stringValue')`: Converts a string to a floating-point number.
*   **Logical functions (often used inside an `if` expression or directly in advanced mode):**
    *   `if(condition, valueIfTrue, valueIfFalse)`
    *   `and(condition1, condition2)`
    *   `or(condition1, condition2)`
    *   `not(condition)`
    *   `empty(value)`: Checks if a value (string, array, object) is empty.
    *   `equals(value1, value2)`: Checks for equality.

**Tallyfy example:**
Let's say you have a Tallyfy [task](/products/pro/tracking-and-tasks/tasks/) with a due date stored as a text [form field](/products/pro/tracking-and-tasks/tasks/what-are-form-fields-in-tallyfy/) called `TaskDueDateText`. Want to check if it's overdue? Here's how:

*   **Value 1 (Expression):** `formatDateTime(outputs('Get_task_details')?['body/forms/TaskDueDateText/value'], 'yyyy-MM-dd')`
    *   This assumes your Tallyfy due date text follows a consistent format. If formats vary (and they often do), you'll need more sophisticated parsing.
*   **Operator:** `is less than`
*   **Value 2 (Expression):** `formatDateTime(utcNow(), 'yyyy-MM-dd')`

## Grouping conditions (AND/OR logic)

You can add multiple rows to a Condition control (as covered in the [basic conditions article](/products/pro/integrations/middleware/power-automate/using-conditional-logic-in-power-automate/)). But what if you need even more complex logic? That's where grouping comes in.

1.  **Add multiple rows:** Click **+ Add** -> **Add row** within your condition.
2.  **Select group:** Check the boxes next to the condition rows you want to group.
3.  **Make group:** Click the ellipsis (...) on one of the selected rows and choose **Make group**.



You can set an AND or OR operator for conditions *within* that group. Then set another AND or OR operator for how that group relates to other conditions or groups at the same level. It's like building logical parentheses around your conditions - perfect for those "if this AND that, OR if something else entirely" scenarios you encounter with real Tallyfy [processes](/products/pro/tracking-and-tasks/processes/).

**Tallyfy example:** Escalate a Tallyfy [process](/products/pro/tracking-and-tasks/processes/) IF:
(Tallyfy [process](/products/pro/tracking-and-tasks/processes/) Name CONTAINS "Urgent" AND Priority [form field](/products/pro/tracking-and-tasks/tasks/what-are-form-fields-in-tallyfy/) IS "High")
OR
(Days Overdue (calculated via expression) IS GREATER THAN 3)

## Using the Switch control for multiple outcomes

Ever created a tangled mess of nested if-this-then-that conditions? You know - checking one Tallyfy [form field](/products/pro/tracking-and-tasks/tasks/what-are-form-fields-in-tallyfy/) value against 5, 10, or even 20 different possibilities? The **Switch** control saves you from that nightmare. It's cleaner, easier to read, and actually maintainable.

*   **Structure:**
    1.  Add a **Switch** control.
    2.  **On:** Specify the value the Switch will evaluate (e.g., dynamic content from a Tallyfy [form field](/products/pro/tracking-and-tasks/tasks/what-are-form-fields-in-tallyfy/)).
    3.  **Case:** For each possible value from your Tallyfy data, add a **Case** branch. In the **Equals** field of the Case, enter the specific value it should match.
    4.  Place the actions for that specific case within its branch.
    5.  **Default:** This branch executes if none of the preceding Case values match the "On" value from Tallyfy.

### How Switch control eliminates nested conditions

This diagram shows how the Switch control provides clean, single-evaluation branching instead of complex nested if-then conditions.

```d2
Access: "Access"
Default: "Default"
End: "End"
Evaluate: "Evaluate"
Hardware: "Hardware"
Info: "Info"
Start: "Start"
"Input": {
Start: "Tallyfy Task with Request"
}
Evaluate: "Evaluate Request Type"
Info: "Information Request"
Access: "Access Request"
Hardware: "Hardware Request"
Default: "Default Handler"
End: "Process Complete"
Start -> Evaluate
Evaluate -> Info: "Information"
Evaluate -> Access: "Access"
Evaluate -> Hardware: "Hardware"
Evaluate -> Default: "Other/Unknown"
Info -> End
Access -> End
Hardware -> End
Default -> End
Hardware.link: "/products/pro/documenting/templates/index/"
Hardware.tooltip: "Learn about procedure templates"
Access.link: "/products/pro/integrations/middleware/power-automate/integrating-power-automate-approvals-with-microsoft-teams/"
Access.tooltip: "Teams approval integration"
```

**What to notice:**
- **Single evaluation point** - The Switch evaluates the Request Type field once, not repeatedly like nested conditions would
- **No nesting required** - Each case branches directly from the central evaluation, keeping your flow clean and readable
- **Default fallback** - Unknown or unexpected values automatically route to a default action, preventing flows from breaking

**Tallyfy example:** Say your Tallyfy [task](/products/pro/tracking-and-tasks/tasks/) has a [form field](/products/pro/tracking-and-tasks/tasks/what-are-form-fields-in-tallyfy/) called "Request Type" with three possible values: "Information," "Access," "Hardware."

*   SWITCH ON: `outputs('Get_task_details')?['body/forms/RequestType/value']` (pulls directly from Tallyfy)
    *   CASE `Information`:
        *   Action: Send an email with links to relevant knowledge base articles.
    *   CASE `Access`:
        *   Action: Create an approval request for system access, perhaps using [Power Automate approvals integrated with Teams](/products/pro/integrations/middleware/power-automate/integrating-power-automate-approvals-with-microsoft-teams/).
    *   CASE `Hardware`:
        *   Action: Launch a Tallyfy "Hardware Procurement" [procedure template](/products/pro/documenting/templates/).
    *   DEFAULT:
        *   Action: Notify IT support about an unclassified request from Tallyfy.

## Advanced conditional patterns

*   **Checking for null or empty values:** Here's a pro tip - always check if optional Tallyfy [form fields](/products/pro/tracking-and-tasks/tasks/what-are-form-fields-in-tallyfy/) are empty before using them. Nothing crashes a flow faster than trying to process a value that doesn't exist. Use the `empty()` expression:
    *   Condition: `empty(outputs('Get_task_details')?['body/forms/OptionalComment/value'])`
    *   Operator: `is equal to`
    *   Value: `true` (expression)
*   **Error handling (Quick note):** You can use "Configure run after" settings on actions within your conditional branches to handle failures gracefully. If a step fails, you can define what happens next - retry, skip, or take an alternative path. This makes your Tallyfy automations resilient to real-world hiccups. More details in [managing and monitoring Power Automate flows](/products/pro/integrations/middleware/power-automate/managing-and-monitoring-power-automate-flows/).

## Best practices for advanced conditions with Tallyfy

*   **Readability:** Keep expressions readable. When logic gets complex, use a "Compose" action (see [working with data operations and variables](/products/pro/integrations/middleware/power-automate/working-with-data-operations-and-variables/)) to build parts of an expression and test its output. Then use that Compose output in your condition. Since Power Automate doesn't let you comment expressions directly, document complex flows externally.
*   **Modularity:** Drowning in nested conditions? Break the flow into smaller, callable child flows. Yes, it adds some management overhead, but it beats staring at 15 levels of indentation.
*   **Data type awareness:** Tallyfy [form fields](/products/pro/tracking-and-tasks/tasks/what-are-form-fields-in-tallyfy/) often store everything as text. Before comparing numbers or dates, convert them properly using `int()`, `float()`, or `formatDateTime()`. Trust me - comparing "10" to 2 as strings will give you unexpected results.
*   **Thorough testing:** Test every single path through your conditions and switches. Feed them different Tallyfy data - valid inputs, edge cases, empty values, the works. Better to find issues in testing than in production.

import { CardGrid, LinkTitleCard } from "~/components";

## Related articles
<CardGrid>
<LinkTitleCard header="<b>Power Automate > Using conditional logic in Power Automate</b>" href="/products/pro/integrations/middleware/power-automate/using-conditional-logic-in-power-automate/" > Power Automate's conditional logic enables automated workflows to make intelligent decisions based on Tallyfy process data using if-then structures that evaluate form fields task statuses and other criteria to trigger different actions and create adaptive business process automations. </LinkTitleCard>
<LinkTitleCard header="<b>Automations > Logic operations explained</b>" href="/products/pro/documenting/templates/automations/logic-explained/" > Tallyfy's automation logic uses simple IF-THEN rules that evaluate user inputs and process conditions to automatically modify workflows and adapt processes to different scenarios without requiring technical expertise. </LinkTitleCard>
<LinkTitleCard header="<b>Conditionals > Conditionals (IF) explained</b>" href="/products/pro/documenting/templates/automations/conditionals/conditionals-explained/" > Tallyfy automations use conditional logic to automatically handle tasks and decisions by checking step statuses or form field content with various operators like "contains" "is completed" or "is approved" to trigger specific actions without manual intervention. </LinkTitleCard>
<LinkTitleCard header="<b>Power Automate > Understanding Power Automate basics</b>" href="/products/pro/integrations/middleware/power-automate/understanding-power-automate-basics/" > Microsoft Power Automate enables workflow automation by connecting Tallyfy with various business applications through triggers and actions while Tallyfy manages human-centric processes and Power Automate handles system integrations and repetitive micro-tasks. </LinkTitleCard>
</CardGrid>