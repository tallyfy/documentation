---
about_tallyfy: false
description: Power Automate's advanced conditional techniques including expressions
  grouped logic and Switch controls enable sophisticated decision-making in Tallyfy
  workflows by handling complex data scenarios multiple conditions and edge cases
  that basic if-then logic cannot accommodate.
id: 6549ab6cc62a4067a4590d9af3164cff
lastUpdated: 2026-03-01
sidebar:
  order: 9
title: Advanced conditions and expressions in Power Automate
---

Basic if-then logic works for simple Tallyfy [processes](/products/pro/tracking-and-tasks/processes/) in Power Automate. But real workflows get messy fast - they need multiple conditions, calculations, and edge case handling. This article covers three techniques for smarter decision-making with Tallyfy data: expressions, grouped conditions, and the Switch control.

## Conditional logic refresher

The **Condition** control - covered in [using conditional logic in Power Automate](/products/pro/integrations/middleware/power-automate/using-conditional-logic-in-power-automate/) - checks whether something's true or false and routes your flow accordingly. The techniques below extend those basics to handle more complex Tallyfy data scenarios.

## Working with expressions in conditions

Expressions are formulas that manipulate Tallyfy data, run calculations, and pull specific properties from dynamic content. Pair them with conditions and you can handle the real-world edge cases in your business processes.

To use an expression:
1.  Click inside the value box when configuring a condition (or any field that accepts expressions).
2.  The dynamic content pane appears. Switch to the **Expression** tab.
3.  Type or select functions to build your expression.



Common expression functions for Tallyfy data:

*   **String functions:**
    *   `concat('string1', 'string2')` - joins strings
    *   `substring('text', startIndex, length)` - extracts part of a string
    *   `toLower('TEXT')` / `toUpper('text')` - converts case (handy for case-insensitive comparisons of Tallyfy [form field](/products/pro/tracking-and-tasks/tasks/what-are-form-fields-in-tallyfy/) values)
    *   `contains('text', 'searchText')` - checks if text includes a substring
    *   `startsWith('text', 'searchText')` / `endsWith('text', 'searchText')`
*   **Date/time functions:**
    *   `utcNow()` - current UTC date and time
    *   `addDays(timestamp, days, 'format')` - adds days to a date (e.g., calculating a new deadline from a Tallyfy [task's](/products/pro/tracking-and-tasks/tasks/) start date)
    *   `formatDateTime(timestamp, 'formatString')` - formats a date/time (e.g., `'yyyy-MM-dd'`)
*   **Conversion functions:**
    *   `int('stringValue')` - string to integer (useful when a Tallyfy [form field](/products/pro/tracking-and-tasks/tasks/what-are-form-fields-in-tallyfy/) stores a number as text)
    *   `string(value)` - value to string
    *   `float('stringValue')` - string to floating-point number
*   **Logical functions:**
    *   `if(condition, valueIfTrue, valueIfFalse)`
    *   `and(condition1, condition2)` / `or(condition1, condition2)` / `not(condition)`
    *   `empty(value)` - checks if a string, array, or object is empty
    *   `equals(value1, value2)` - checks for equality

**Tallyfy example - checking if a task is overdue:**

Suppose a Tallyfy [task](/products/pro/tracking-and-tasks/tasks/) stores its due date in a text [form field](/products/pro/tracking-and-tasks/tasks/what-are-form-fields-in-tallyfy/) called `TaskDueDateText`:

*   **Value 1 (Expression):** `formatDateTime(outputs('Get_task_details')?['body/forms/TaskDueDateText/value'], 'yyyy-MM-dd')`
    *   This assumes a consistent date format. If formats vary, you'll need additional parsing.
*   **Operator:** `is less than`
*   **Value 2 (Expression):** `formatDateTime(utcNow(), 'yyyy-MM-dd')`

## Grouping conditions (AND/OR logic)

The [basic conditions article](/products/pro/integrations/middleware/power-automate/using-conditional-logic-in-power-automate/) covers adding multiple rows to a Condition control. Grouping takes this further by letting you nest logic.

1.  **Add multiple rows:** Click **+ Add** > **Add row** within your condition.
2.  **Select rows:** Check the boxes next to the condition rows you want to group.
3.  **Make group:** Click the ellipsis (...) on a selected row and choose **Make group**.



Each group gets its own AND/OR operator, and you set a separate AND/OR for how that group relates to other conditions at the same level. This works like parentheses in logic - great for "if this AND that, OR if something else entirely" scenarios with Tallyfy [processes](/products/pro/tracking-and-tasks/processes/).

**Tallyfy example:** Escalate a [process](/products/pro/tracking-and-tasks/processes/) IF:
(Process Name CONTAINS "Urgent" AND Priority [form field](/products/pro/tracking-and-tasks/tasks/what-are-form-fields-in-tallyfy/) IS "High")
OR
(Days Overdue (calculated via expression) IS GREATER THAN 3)

## Using the Switch control for multiple outcomes

When you're checking one Tallyfy [form field](/products/pro/tracking-and-tasks/tasks/what-are-form-fields-in-tallyfy/) value against many possible matches, nested conditions get unwieldy fast. The **Switch** control is cleaner, easier to read, and simpler to maintain.

*   **Structure:**
    1.  Add a **Switch** control.
    2.  **On:** Set the value to evaluate (e.g., a Tallyfy [form field](/products/pro/tracking-and-tasks/tasks/what-are-form-fields-in-tallyfy/) via dynamic content).
    3.  **Case:** Add a **Case** branch for each possible value. Enter the matching value in the **Equals** field.
    4.  Place the actions for that case inside its branch.
    5.  **Default:** Runs if none of the Case values match.

### How Switch control eliminates nested conditions

This diagram shows how the Switch control provides clean, single-evaluation branching instead of complex nested if-then conditions.

```d2
direction: down

# Start
Start: Tallyfy Task {
  shape: circle
  style.fill: "#e1f7e6"
  style.stroke: "#225930"
  style.stroke-width: 2
}

# Evaluation
Evaluate: Evaluate Type {
  shape: diamond
  style.fill: "#f2faf4"
  style.stroke: "#225930"
}

# Case Branches
Info: Info Request {
  shape: rectangle
  style.fill: "#f2faf4"
  style.stroke: "#225930"
}

Access: Access Request {
  shape: rectangle
  style.fill: "#f2faf4"
  style.stroke: "#225930"
}

Hardware: Hardware Request {
  shape: rectangle
  style.fill: "#f2faf4"
  style.stroke: "#225930"
}

Default: Default Handler {
  shape: rectangle
  style.fill: "#fff3cd"
  style.stroke: "#225930"
}

# End
End: Process Complete {
  shape: circle
  style.fill: "#e1f7e6"
  style.stroke: "#225930"
  style.stroke-width: 2
}

# Flow
Start -> Evaluate {
  style.stroke: "#225930"
  style.stroke-width: 2
}

Evaluate -> Info: Information {
  style.stroke: "#225930"
}

Evaluate -> Access: Access {
  style.stroke: "#225930"
}

Evaluate -> Hardware: Hardware {
  style.stroke: "#225930"
}

Evaluate -> Default: Other/Unknown {
  style.stroke: "#225930"
  style.stroke-dash: 3
}

Info -> End {
  style.stroke: "#225930"
}

Access -> End {
  style.stroke: "#225930"
}

Hardware -> End {
  style.stroke: "#225930"
}

Default -> End {
  style.stroke: "#225930"
  style.stroke-dash: 3
}
```

**What to notice:**
- **Single evaluation point** - The Switch evaluates the Request Type field once, not repeatedly like nested conditions would
- **No nesting required** - Each case branches directly from the central evaluation, keeping your flow clean and readable
- **Default fallback** - Unknown or unexpected values automatically route to a default action, preventing flows from breaking

**Tallyfy example:** A [task](/products/pro/tracking-and-tasks/tasks/) has a [form field](/products/pro/tracking-and-tasks/tasks/what-are-form-fields-in-tallyfy/) called "Request Type" with values "Information," "Access," and "Hardware."

*   SWITCH ON: `outputs('Get_task_details')?['body/forms/RequestType/value']`
    *   CASE `Information`: Send an email with knowledge base links.
    *   CASE `Access`: Create an approval request, possibly using [Power Automate approvals with Teams](/products/pro/integrations/middleware/power-automate/integrating-power-automate-approvals-with-microsoft-teams/).
    *   CASE `Hardware`: Launch a Tallyfy "Hardware Procurement" [template](/products/pro/documenting/templates/).
    *   DEFAULT: Notify IT support about an unclassified request.

## Advanced conditional patterns

*   **Checking for null or empty values:** Always check if optional Tallyfy [form fields](/products/pro/tracking-and-tasks/tasks/what-are-form-fields-in-tallyfy/) are empty before using them - otherwise your flow crashes when the value doesn't exist. Use `empty()`:
    *   Condition: `empty(outputs('Get_task_details')?['body/forms/OptionalComment/value'])`
    *   Operator: `is equal to`
    *   Value: `true` (expression)
*   **Error handling:** Use "Configure run after" settings on actions within conditional branches to handle failures. If a step fails, you can retry, skip, or take an alternative path. More details in [managing and monitoring Power Automate flows](/products/pro/integrations/middleware/power-automate/managing-and-monitoring-power-automate-flows/).

## Best practices for advanced conditions with Tallyfy

*   **Readability:** Use a "Compose" action (see [working with data operations and variables](/products/pro/integrations/middleware/power-automate/working-with-data-operations-and-variables/)) to build and test complex expressions before plugging them into conditions. Power Automate doesn't support inline comments, so document complex logic externally.
*   **Modularity:** If you're drowning in nested conditions, break the flow into smaller child flows. It adds management overhead but keeps things maintainable.
*   **Data type awareness:** Tallyfy [form fields](/products/pro/tracking-and-tasks/tasks/what-are-form-fields-in-tallyfy/) often store values as text. Convert before comparing - use `int()`, `float()`, or `formatDateTime()`. Comparing "10" to 2 as strings produces wrong results.
*   **Testing:** Test every path through your conditions and switches with different Tallyfy data - valid inputs, edge cases, and empty values. Catch issues before production.

import { CardGrid, LinkTitleCard } from "~/components";

## Related articles
<CardGrid>
<LinkTitleCard header="<b>Power Automate > Using conditional logic in Power Automate</b>" href="/products/pro/integrations/middleware/power-automate/using-conditional-logic-in-power-automate/" > Power Automate's conditional logic enables automated flows to make intelligent decisions based on Tallyfy data using IF-THEN structures Switch controls and nested conditions to create adaptive workflows that respond differently to various task statuses form field values and process conditions. </LinkTitleCard>
<LinkTitleCard header="<b>Automations > Logic operations explained</b>" href="/products/pro/documenting/templates/automations/logic-explained/" > Tallyfy's automation logic uses simple IF-THEN rules that watch user inputs and automatically adjust workflows based on conditions like form selections task approvals or specific requirements while combining multiple conditions with AND/OR logic to create intelligent processes that adapt to different business scenarios. </LinkTitleCard>
<LinkTitleCard header="<b>Conditionals > Conditionals (IF) explained</b>" href="/products/pro/documenting/templates/automations/conditionals/conditionals-explained/" > Tallyfy automations use conditional logic to automatically handle tasks and decisions by checking step statuses or form field content with various operators like "contains" "is completed" or "is approved" to trigger specific actions without manual intervention. </LinkTitleCard>
<LinkTitleCard header="<b>Power Automate > Understanding Power Automate basics</b>" href="/products/pro/integrations/middleware/power-automate/understanding-power-automate-basics/" > Microsoft Power Automate enables workflow automation by connecting Tallyfy with various business applications through triggers and actions while Tallyfy manages human-centric processes and Power Automate handles system integrations and repetitive micro-tasks. </LinkTitleCard>
</CardGrid>