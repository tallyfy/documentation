---
about_tallyfy: true
description: SSO integration with MCP servers eliminates the need for separate credentials
  across multiple AI tools by delegating authentication to enterprise identity providers
  like Azure AD and Okta through OAuth 2.1 flows that handle token exchange and access
  control automatically while addressing challenges like consent fatigue and shadow
  OAuth visibility.
id: 886f31f99a9a826905f2790c69b808fd
lastUpdated: 2026-02-25
sidebar:
  order: 25
title: Using SSO with MCP servers
---

import { Steps, CardGrid, LinkTitleCard } from "~/components";

:::note[Advanced integration topic]
This article covers authentication patterns for MCP servers using enterprise SSO systems. Most implementations require custom development and careful security planning.
:::

## What SSO does for MCP servers

SSO integration with MCP servers solves **repeated authentication across multiple AI tools**. Instead of juggling separate credentials for each integration, your corporate credentials unlock access to all approved workflow tools in one step.

Tallyfy's MCP server already implements OAuth 2.1 with PKCE, Dynamic Client Registration (RFC 7591), and authorization server metadata discovery (RFC 8414). The well-known endpoint at `/.well-known/oauth-authorization-server` lets AI clients like ChatGPT and Claude Desktop discover OAuth endpoints automatically. Scopes use dot notation - for example, `mcp.tasks.read`, `mcp.processes.write`, and `mcp.templates.read`.

## The authentication challenge in MCP

MCP servers don't know who you are by default. They receive requests from AI agents with no identity or context. This creates gaps when accessing enterprise systems that need user credentials.

**Common workarounds and their problems:**
- Embedding API keys as environment variables - doesn't scale
- OAuth Device Authorization Flow for local servers - clunky UX
- Manual token management per tool - shadow IT risk and compliance headaches

## How SSO bridges the gap

SSO integration with MCP uses OAuth 2.1 flows that delegate authentication to enterprise identity providers.

### Interactive delegation flow

1. **User initiates connection** - AI agent requests access to a tool
2. **SSO redirect** - MCP server redirects user to corporate identity provider
3. **Corporate authentication** - user logs in with SSO credentials (including MFA)
4. **Token exchange** - identity provider returns an authorization code, which the MCP server exchanges for an access token
5. **API access** - MCP server uses the token to call service APIs

This diagram shows how SSO authentication flows between users, AI agents, MCP servers, and identity providers.

```d2
# SSO Authentication Flow with MCP
direction: down

# Actors
User: User {
  shape: person
  style.fill: "#e1f7e6"
}

AI_Agent: AI Agent {
  shape: rectangle
  style.fill: "#f2faf4"
}

MCP_Server: MCP Server {
  shape: rectangle
  style.fill: "#f2faf4"
}

IdP: Identity Provider {
  shape: rectangle
  style.fill: "#f2faf4"
  label: "Identity Provider\n(Azure AD, Okta, etc.)"
}

API: Target Service API {
  shape: cylinder
  style.fill: "#f2faf4"
}

# Authentication Flow
User -> AI_Agent: 1. Request access\nto tool {
  style.stroke: "#225930"
}

AI_Agent -> MCP_Server: 2. Forward request {
  style.stroke: "#225930"
}

MCP_Server -> User: 3. Redirect to IdP {
  style.stroke: "#225930"
  style.stroke-dash: 3
}

User -> IdP: 4. Login with\ncorporate credentials {
  style.stroke: "#225930"
  style.stroke-width: 2
}

IdP -> IdP: 5. Validate MFA &\nAccess Policies {
  style.stroke: "#225930"
}

IdP -> User: 6. Authorization code {
  style.stroke: "#225930"
  style.stroke-dash: 3
}

User -> MCP_Server: 7. Return with code {
  style.stroke: "#225930"
}

MCP_Server -> IdP: 8. Exchange code\nfor access token {
  style.stroke: "#225930"
  style.stroke-width: 2
}

IdP -> MCP_Server: 9. Access token {
  style.stroke: "#225930"
  style.stroke-width: 2
}

MCP_Server -> API: 10. API request\nwith token {
  style.stroke: "#225930"
  style.stroke-width: 2
}

API -> MCP_Server: 11. API response {
  style.stroke: "#225930"
  style.stroke-dash: 3
}

MCP_Server -> AI_Agent: 12. Return data {
  style.stroke: "#225930"
  style.stroke-dash: 3
}

AI_Agent -> User: 13. Present results {
  style.stroke: "#225930"
}
```

**What to notice:**
- **Step 4-5**: The identity provider validates corporate credentials including MFA and conditional access policies before issuing tokens
- **Step 8-9**: The MCP server handles token exchange automatically - users never see raw tokens
- **Steps 10-13**: Once authenticated, the MCP server can make multiple API calls on behalf of the user without further prompts

### Bearer token acceptance

Advanced implementations let MCP servers accept existing SSO tokens directly:

- AI client presents a valid OIDC ID token or access token from the identity provider
- MCP server verifies token authenticity and extracts user permissions
- Server performs token exchange to get service-specific API credentials
- Already-authenticated users skip additional login prompts

## Identity provider support

### Microsoft Entra ID (Azure AD)

- Full OAuth 2.1 and OIDC support with PKCE
- On-behalf-of (OBO) token exchange for Microsoft Graph APIs
- Conditional Access Policies apply automatically to MCP connections
- Native integration with Microsoft 365 and Azure services

**Limitations:** Tokens are designed primarily for Microsoft APIs. No native cross-provider token exchange. Each MCP server must be registered as an app manually.

### Okta

- OAuth 2.0 with device flow support
- Custom authorization servers for API-specific scopes
- Dynamic client registration and flexible token refresh
- Okta Integration Network (OIN) listing for one-click deployment
- SCIM provisioning for automated user management

**Discovery:** Okta supports both `/.well-known/openid-configuration` and `/.well-known/oauth-authorization-server` (RFC 8414). The RFC 8414 endpoint is the standard for pure OAuth 2.0 flows.

### Google Workspace Identity

- OAuth provider for Google services (Gmail, Drive, Calendar) and OIDC identity provider for third-party apps
- Domain-wide delegation lets admins pre-authorize applications and service accounts
- Admin-managed app whitelisting and Google Workspace Marketplace integration

### OneLogin and other providers

Most enterprise identity providers offer SAML 2.0 and OIDC/OAuth 2.0 compatibility with similar token exchange limitations and marketplace integration options.

## Current gaps and challenges

### Repeated consent fatigue

Users face multiple OAuth consent flows for each tool integration, even when using the same SSO credentials. An employee with email, calendar, Slack, GitHub, and Salesforce integrations hits five separate login prompts.

### Shadow OAuth visibility

Token exchanges between AI applications and services often happen outside IT's oversight. There's no centralized view of which apps access which data for which users - making offboarding and access revocation difficult.

### Implementation complexity

Each MCP server developer must implement OAuth components (authorization endpoints, token management, client registration). Building secure OAuth flows requires specialized knowledge, and mistakes introduce vulnerabilities.

### Token lifecycle management

Coordinating token refresh, expiration, and revocation across multiple identity domains remains hard. There's no universal token exchange between providers, and revocation signals don't propagate consistently.

## Solution approaches

### Centralized profile system

A cloud service acts as a universal integration broker - similar to [mcp.run's profile system](https://docs.mcp.run/blog/2025/05/14/mcp-sso/). Users connect tools once on a dashboard, group them into profiles, and AI applications request access to the whole profile through a single OAuth flow.

The bridge service becomes the OAuth Authorization Server, storing encrypted API credentials in a token vault, routing MCP requests to appropriate services, and providing centralized audit logging.

### Enterprise IdP extensions

An add-on for existing identity providers handles inter-application authorization. When an AI application needs a Slack token, it asks the mediation service, which validates the user's identity with the corporate IdP, checks admin policies, and returns the token - all without user interaction.

This gives admins a dashboard for approving or denying AI-to-app connections with centralized policy enforcement and audit trails.

### Developer SDK approach

Pre-built SDKs make OAuth manageable for MCP server developers by providing integrations for major identity providers, automatic token refresh, and consistent security patterns.

## Implementation strategies

### OAuth 2.1 standard compliance

Tallyfy's MCP server already follows these OAuth 2.1 patterns. Here's what any MCP implementation needs:

<Steps>

1. **Use PKCE for all flows**

   PKCE protects against authorization code interception. Tallyfy requires S256 code challenge method - no plain text allowed.

2. **Implement metadata discovery**

   Expose `/.well-known/oauth-authorization-server` per RFC 8414. This lets AI clients discover authorization, token, and registration endpoints automatically.

3. **Enable dynamic client registration**

   RFC 7591 support lets AI applications register with MCP servers programmatically. Tallyfy's DCR endpoint validates redirect URIs and blocks localhost domains.

4. **Plan for token exchange**

   OAuth 2.0 Token Exchange (RFC 8693) enables on-behalf-of scenarios. Tallyfy implements refresh token rotation with reuse detection to protect against stolen tokens.

</Steps>

### Security considerations

**Token storage:** Use encrypted key vaults, short-lived access tokens with refresh mechanisms, and monitor for unusual API usage patterns.

**Network security:** Require HTTPS for all authentication endpoints. Tallyfy's MCP OAuth endpoints include rate limiting - 5 registrations per hour for DCR, 60 token requests per minute.

**Access control:** Map SSO roles to MCP tool permissions using scopes like `mcp.tasks.read` and `mcp.processes.write`. Support conditional access policies from identity providers.

## Best practices for enterprises

### Governance and compliance

Define approved AI applications and integrations. Document data access requirements. Log all token exchanges and API access, and schedule regular permission audits.

### User experience optimization

Minimize authentication friction by using existing SSO sessions. Group related tools into logical profiles. Support different client types - web apps use authorization code flow, desktop apps use device authorization flow, and CLI tools use client credentials or device flow.

### Technical architecture

Cache tokens to reduce identity provider load. Implement circuit breakers for external API calls and design graceful degradation when identity services go down.

## Integration with popular providers

### Microsoft identity providers

Register as an Enterprise Application in Azure AD Gallery. Use Entra ID authentication for Copilot Studio connectors - enterprise security controls apply automatically.

### Okta Integration Network

Submit through OIN: create an integration in Okta's developer org, implement OIDC flow, add SCIM provisioning if applicable, then submit for certification. Okta customers get one-click configuration.

### Google Workspace Marketplace

Requires OAuth application verification, privacy policy documentation, and minimal scope usage. Domain-wide installation gives admins centralized permission management.

## What's changing

The OpenID Foundation is developing cross-domain authorization chaining standards. OAuth 2.0 extensions will enable more flexible cross-provider token exchange. AI-specific authentication protocols are also in development.

The trend is moving toward user-controlled integration profiles that travel between AI applications, zero-trust architecture integration, and stronger audit trails for regulatory compliance.

## Related articles
<CardGrid>
<LinkTitleCard header="<b>Integrations > Authentication and SSO</b>" href="/products/pro/integrations/authentication/" > Tallyfy offers free Single Sign-On integration for paid plans connecting to corporate identity systems like Microsoft Entra ID Google Workspace Okta and OneLogin with SSO-only enforcement options that can replace traditional e-signatures for internal approvals while providing enhanced security user experience and centralized access control through automated account provisioning and unified authentication policies. </LinkTitleCard>
<LinkTitleCard header="<b>Mcp Server > Using Tallyfy MCP server with Microsoft Copilot Studio</b>" href="/products/pro/integrations/mcp-server/microsoft-copilot-studio/" > Microsoft Copilot Studio provides enterprise-grade MCP integration with Tallyfy through Azure Functions and Power Platform custom connectors enabling multi-agent orchestration for complex workflows like employee onboarding with features including Virtual Network isolation and Data Loss Prevention policies and deep integration with Dynamics 365 and Power BI though it requires multiple license tiers and has regional availability limitations. </LinkTitleCard>
<LinkTitleCard header="<b>Authentication > Integrate Microsoft Entra ID SSO</b>" href="/products/pro/integrations/authentication/how-to-integrate-azure-ad-samlsso-with-tallyfy/" > This guide walks through connecting Microsoft Entra ID to Tallyfy for single sign-on authentication by creating an enterprise application in Azure Portal and configuring SAML settings with attribute mappings while coordinating with Tallyfy Support to exchange metadata and enable automatic user provisioning. </LinkTitleCard>
<LinkTitleCard header="<b>Integrations > MCP server</b>" href="/products/pro/integrations/mcp-server/" > Tallyfy's MCP Server enables natural language interaction with workflows through AI assistants by providing tools for searching tasks and processes managing users and templates analyzing workflow health and creating automation rules without requiring API knowledge. </LinkTitleCard>
</CardGrid>